# /etc/unbound.conf 
# last revised 2020-06-10

#Use this to include other text into the file.
#include: "otherfile.conf"

# The server clause sets the main parameters.
server:
	#required modules for RPZ
	module-config: "respip validator iterator"

	# verbosity number, 0 is least verbose. 1 is default.
	verbosity: 1

        # number of threads to create. 1 disables threading.
	num-threads: 4

        # specify the interfaces to answer queries from by ip-address.
        # The default is to listen to localhost (127.0.0.1 and ::1).
        # specify 0.0.0.0 and ::0 to bind to all available interfaces.
        # specify every interface[@port] on a new 'interface:' labelled line.
        # The listen interfaces are not changed on reload, only on restart.
        # interface: 192.0.2.153
        # interface: 192.0.2.154
        # interface: 192.0.2.154@5003
        # interface: 2001:DB8::5
	interface: ::0@53
	interface: ::0@853
	interface: 0.0.0.0@53
	interface: 0.0.0.0@853
	interface: 127.0.0.1

        # port to answer queries from
	port: 53

        # Set this to yes to prefer ipv6 upstream servers over ipv4.
	prefer-ip6: no

        # number of ports to allocate per thread, determines the size of the
        # port range that can be open simultaneously.  About double the
        # num-queries-per-thread, or, use as many as the OS will allow you.
	outgoing-range: 4096

        # number of outgoing simultaneous tcp buffers to hold per thread.
	outgoing-num-tcp: 1000

        # number of incoming simultaneous tcp buffers to hold per thread.
	incoming-num-tcp: 1000

        # buffer size for UDP port 53 incoming (SO_RCVBUF socket option).
        # 0 is system default.  Use 4m to catch query spikes for busy servers.
	so-rcvbuf: 4m

        # buffer size for UDP port 53 outgoing (SO_SNDBUF socket option).
        # 0 is system default.  Use 4m to handle spikes on very busy servers.
	so-sndbuf: 4m

        # use SO_REUSEPORT to distribute queries over threads.
        # at extreme load it could be better to turn it off to distribute even.
	so-reuseport: yes

        # EDNS reassembly buffer to advertise to UDP peers (the actual buffer
        # is set with msg-buffer-size). 1472 can solve fragmentation (timeouts)
	edns-buffer-size: 4096

        # Maximum UDP response size (not applied to TCP response).
        # Suggested values are 512 to 4096. Default is 4096. 65536 disables it.
	max-udp-size: 4096

        # max memory to use for stream(tcp and tls) waiting result buffers.
	stream-wait-size: 8m

        # the amount of memory to use for the message cache.
        # plain value in bytes or you can append k, m or G. default is "4Mb".
	msg-cache-size: 8m

        # the number of slabs to use for the message cache.
        # the number of slabs must be a power of 2.
        # more slabs reduce lock contention, but fragment memory usage.
	msg-cache-slabs: 8

        # the number of queries that a thread gets to service.
	num-queries-per-thread: 1024

        # the amount of memory to use for the RRset cache.
        # plain value in bytes or you can append k, m or G. default is "4Mb".
	rrset-cache-size: 2G

        # the number of slabs to use for the RRset cache.
        # the number of slabs must be a power of 2.
        # more slabs reduce lock contention, but fragment memory usage.
	rrset-cache-slabs: 8

        # the time to live (TTL) value cap for RRsets and messages in the
        # cache. Items are not cached for longer. In seconds.
	cache-max-ttl: 900

        # the time to live (TTL) value cap for negative responses in the cache
	cache-max-negative-ttl: 60

        # Enable IPv4, "yes" or "no".
	do-ip4: yes

        # Enable IPv6, "yes" or "no".
	do-ip6: yes

        # Enable UDP, "yes" or "no".
	do-udp: yes

        # Enable TCP, "yes" or "no".
	do-tcp: yes

        # upstream connections also use UDP (even if do-udp is no).
        # useful if if you want UDP upstream, but don't provide UDP downstream.
	udp-upstream-without-downstream: yes

        # Detach from the terminal, run in background, "yes" or "no".
        # Set the value to "no" when unbound runs as systemd service.
	do-daemonize: no

        # control which clients are allowed to make (recursive) queries
        # to this server. Specify classless netblocks with /size and action.
        # By default everything is refused, except for localhost.
        # Choose deny (drop message), refuse (polite error reply),
        # allow (recursive ok), allow_setrd (recursive ok, rd bit is forced on),
        # allow_snoop (recursive and nonrecursive ok)
        # deny_non_local (drop queries unless can be answered from local-data)
        # refuse_non_local (like deny_non_local but polite error reply).
        # access-control: 0.0.0.0/0 refuse
        # access-control: 127.0.0.0/8 allow
        # access-control: ::0/0 refuse
        # access-control: ::1 allow
        # access-control: ::ffff:127.0.0.1 allow
	access-control: ::1 allow_snoop
	access-control: 0.0.0.0/0 refuse
	access-control: 127.0.0.0/8 allow_snoop
	access-control: 10.0.0.0/8 allow_snoop
	access-control: 172.16.0.0/12 allow_snoop
	access-control: 192.168.0.0/16 allow_snoop

        # if given, user privileges are dropped (after binding port),
        # and the given username is assumed. Default is user "unbound".
        # If you give "" no privileges are dropped.
	username: ""

        # the working directory. The relative files in this config are
        # relative to this directory. If you give "" the working directory
        # is not changed.
        # If you give a server: directory: dir before include: file statements
        # then those includes can be relative to the working directory.
	directory: "/etc/unbound"

        # the log file, "" means log to stderr.
        # Use of this option sets use-syslog to "no".
	logfile: "/etc/unbound/log"

        # Log to syslog(3) if yes. The log facility LOG_DAEMON is used to
        # log to. If yes, it overrides the logfile.
	use-syslog: no

        # Log identity to report. if empty, defaults to the name of argv[0]
        # (usually "unbound").
	log-identity: "unbound"

        # print UTC timestamp in ascii to logfile, default is epoch in seconds.
	log-time-ascii: yes

        # print one line with time, IP, name, type, class for every query.
	log-queries: no

        # print one line per reply, with time, IP, name, type, class, rcode,
        # timetoresolve, fromcache and responsesize.
	log-replies: no

        # print log lines that say why queries return SERVFAIL to clients.
	log-servfail: no

        # the pid file. Can be an absolute path outside of chroot/work dir.
	pidfile: "/etc/unbound/unbound.pid"

        # file to read root hints from.
        # get one from https://www.internic.net/domain/named.cache
	root-hints: "/etc/unbound/root.cache"

        # enable to not answer id.server and hostname.bind queries.
	hide-identity: no

        # enable to not answer version.server and version.bind queries.
	hide-version: yes

        # enable to not answer trustanchor.unbound queries.
	hide-trustanchor: yes

        # the identity to report. Leave "" or default to return hostname.
	identity: ""

        # the version to report. Leave "" or default to return package version.
	version: ""

        # Harden against out of zone rrsets, to avoid spoofing attempts.
	harden-glue: yes

        # Sent minimum amount of information to upstream servers to enhance
        # privacy. Only sent minimum required labels of the QNAME and set QTYPE
        # to A when possible.
	qname-minimisation: yes

        # QNAME minimisation in strict mode. Do not fall-back to sending full
        # QNAME to potentially broken nameservers. A lot of domains will not be
        # resolvable when this option in enabled.
        # This option only has effect when qname-minimisation is enabled.
	qname-minimisation-strict: no

        # if yes, perform prefetching of almost expired message cache entries.
	prefetch: no

        # deny queries of type ANY with an empty response.
	deny-any: yes

        # if yes, Unbound doesn't insert authority/additional sections
        # into response messages when those sections are not required.
	minimal-responses: no

        # The time to live for bogus data, rrsets and messages. This avoids
        # some of the revalidation, until the time interval expires. in secs.
	val-bogus-ttl: 60

        # Serve expired responses from cache, with TTL 0 in the response,
        # and then attempt to fetch the data afresh.
	serve-expired: no

        # service clients over TLS (on the TCP sockets), with plain DNS inside
        # the TLS stream.  Give the certificate to use and private key.
        # default is "" (disabled).  requires restart to take effect.
	#tls-service-key: "/etc/letsencrypt/live/[server-name]/privkey.pem"
	#tls-service-pem: "/etc/letsencrypt/live/[server-name]/fullchain.pem"
	#tls-port: 853

	# cipher setting for TLSv1.2
	#tls-ciphers: "DHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA256"
	# cipher setting for TLSv1.3
	#tls-ciphersuites: "TLS_AES_128_GCM_SHA256:TLS_AES_128_CCM_8_SHA256:TLS_AES_128_CCM_SHA256:TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256"

	# Add the secret file for TLS Session Ticket.
	# Secret file must be 80 bytes of random data.
	# First key use to encrypt and decrypt TLS session tickets.
	# Other keys use to decrypt only.
	# requires restart to take effect.
	#tls-session-ticket-keys: "/etc/unbound/secret1"
	#tls-session-ticket-keys: "/etc/unbound/secret2"

        # request upstream over TLS (with plain DNS inside the TLS stream).
        # Default is no.  Can be turned on and off with unbound-control.
	tls-upstream: no

        # Certificates used to authenticate connections made upstream.
	#tls-cert-bundle: "/etc/ssl/certs/ca-certificates.crt"

# Python config section. To enable:
# o use --with-pythonmodule to configure before compiling.
# o list python in the module-config string (above) to enable.
#   It can be at the start, it gets validated results, or just before
#   the iterator and process before DNSSEC validation.
# o and give a python-script to run.
python:
        # Script file to load
        # python-script: "/etc/unbound/ubmodule-tst.py"

# Remote control config section.
remote-control:
        # Enable remote control with unbound-control(8) here.
        # set up the keys and certificates with unbound-control-setup.
	control-enable: yes

        # what interfaces are listened to for remote control.
        # give 0.0.0.0 and ::0 to listen to all interfaces.
        # set to an absolute path to use a unix local name pipe, certificates
        # are not used for that, so key and cert files need not be present.
	control-interface: 127.0.0.1

        # port number for remote control operations.
	control-port: 8953

        # for localhost, you can disable use of TLS by setting this to "no"
        # For local sockets this option is ignored, and TLS is not used.
	control-use-cert: "yes"

        # unbound server key file.
	server-key-file: "/etc/unbound/unbound_server.key"

        # unbound server certificate file.
	server-cert-file: "/etc/unbound/unbound_server.pem"

        # unbound-control key file.
	control-key-file: "/etc/unbound/unbound_control.key"

        # unbound-control certificate file.
	control-cert-file: "/etc/unbound/unbound_control.pem"

#------------------------------------------------------------------------------
# Response Policy Zones (RPZ)
#
# RPZ policies are applied in the order that they appear in the configuration
# file.  Unbound currently supports hostname/domain and ip/cidr type rules.
# Nameserver name (NSDNAME) and nameserver IPs (NSIP) are not yet supported.
#
# Supported actions for RPZ triggers include NXDOMAIN, NODATA, PASSTHRU, DROP
# and local Data. For most use cases, "rewrites" generally return NXDOOMAIN
# responses, which is a fancy way of saying "no such answer".
#
# In order to use RPZ functionality within Unbound the respip module needs to
# be added to the server section of the unbound.conf config file.
# The entry should look like 
#     module-config: "respip validator iterator"
#
# The basic syntax for adding an RPZ zone is:
#
#rpz:
#	name: [zone-name]
#	zonefile: zonefiles/[zone-name]
#	master: [distribution-masters]
#	rpz-log: yes
#	rpz-log-name: [zone-name]
# 
# The above example would require "[zone-name]" to be replaced with the actual
# name of the response policy zone (e.g. "drop.ip.dtq") and the IP address or
# hostname of the server that is authoritative for that zone and provides
# AXFR/IXFR downloads.  

# Below are example configs for Deteque/Spamhaus RPZ zones. You can, however,
# leverage any third party zones using this docker image, as well as create
# zones of your own.

#------------------------------------------------------------------------------
# Deteque/Spamhaus "Don't Route or Peer" (DROP) RPZ zone
#	This rpz zone contains listings of ip addresses and networks that are
#	contained in the DROP zone.  The entries in this list represent hosts
# 	and networks whose address space is hijacked or leased by professional
#	spam or cyber-crime operations and used for dissemination of malware,
#	trojan downloaders and botnet controllers.  Those who control the
#	address space fail to respond to abuse requests and are often referred
#	to as "bulletproof hosting" companies.
#
#	Anyone deploying an RPZ enabled recursive should include this RPZ zone
#	as the first zone in their response policy.  This is a relatively small
#	rpz zone.
#
#	We make this zone freely available to anyone.  As such, the configuration
# 	example below includes all the information and access needed to pull the
#	zone via IXFR.
#------------------------------------------------------------------------------

rpz:
	name: drop.ip.dtq
	zonefile: zonefiles/drop.ip.dtq
	master: US.spamhaus.zone
	master: EU.spamhaus.zone
	rpz-log: yes
	rpz-log-name: drop.ip.dtq

#------------------------------------------------------------------------------
# Deteque Third Party RPZ Zones
#	The below listed RPZ zones are created using third party data and 
# 	therefore may contain listings that produce false positives.  While
#	we do make these available free of charge we do not guarantee the
#	quality of the content.
#
#	The coinblocker zone contains listings of sites known to download
#	programs that mine for bitcoins, etc.  The porn zone contains sites
#	known to distribute adult/pornographici material.  The torblock zone
#	contains ip addresses of known Tor exit nodes.
#       - coinblocker.srv
#       - porn.host.srv
#       - torblock.srv
#
# 	These RPZ zones are freely published and the master settings for
#	these zones are actually live.  You can use them initially for
#	testing, then decide if you want to continue using them in your
#	response policy security profile.
#------------------------------------------------------------------------------

rpz:
	name: coinblocker.srv
	zonefile: zonefiles/coinblocker.srv
	master: US.spamhaus.zone
	master: EU.spamhaus.zone
	rpz-log: yes
	rpz-log-name: coinblocker.srv

rpz:
	name: porn.host.srv
	zonefile: zonefiles/porn.host.srv
	master: US.spamhaus.zone
	master: EU.spamhaus.zone
	rpz-log: yes
	rpz-log-name: port.host.srv

rpz:
	name: torblock.srv
	zonefile: zonefiles/torblock.srv
	master: US.spamhaus.zone
	master: EU.spamhaus.zone
	rpz-log: yes
	rpz-log-name: torblock.srv

#------------------------------------------------------------------------------
# Deteque Abused Legit RPZ Zones
#	Abused legit RPZ zonefiles contain listings of otherwise legitimate
#	sites that appear to be compromised and being used to send spam,
#	act as a botnet command and control server or serving malware.  
#	While it is totally legitimate to block these sites, please be
#	advised that these listing may result in user complaints, most
#	often resembling "why can't I access a site I've been using for
#	years?".  We do agressively purge listings in this zone once we
#	confirm that the site has been cleaned up.
#
#	- badrep.hacked.host.dtq
#       - botnetcc.hacked.host.dtq
#       - botnetcc.hacked.ip.dtq
#       - malware.hacked.host.dtq
#	- phish.hacked.host.dtq
#------------------------------------------------------------------------------

#rpz:
# 	name: badrep.hacked.host.dtq
# 	zonefile: zonefiles/badrep.hacked.host.dtq
# 	master: <distribution-masters>
# 	rpz-log: yes
# 	rpz-log-name: badrep.hacked.host.dtq

#rpz:
# 	name: botnetcc.hacked.host.dtq
# 	zonefile: zonefiles/botnetcc.haacked.host.dtq
# 	master: <distribution-masters>
# 	rpz-log: yes
# 	rpz-log-name: botnetcc.hacked.host.dtq

#rpz:
# 	name: botnetcc.hacked.ip.dtq
# 	zonefile: zonefiles/botnetcc.hacked.ip.dtq
# 	master: <distribution-masters>
# 	rpz-log: yes
# 	rpz-log-name: botnetcc.hacked.ip.dtq

#rpz:
# 	name: malware.hacked.host.dtq
# 	zonefile: zonefiles/malware.hacked.host.dtq
# 	master: <distribution-masters>
# 	rpz-log: yes
# 	rpz-log-name: malware.hacked.host.dtq

#rpz:
#	name: phish.hacked.host.dtq
#	zonefile: zonefiles/phish.hacked.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: phish.hacked.host.dtq

#------------------------------------------------------------------------------
# Deteque Botnet RPZ Zones
#	These RPZ zones are designed to block outbound connections to sites
#	known to be botnet command and control servers.  Zones with "edit"
#	in the name represent a subnet of data that contains sites with a 
#	poorer reputation score.
#
#	The dga.host.dtq zone contains domains that are automatically 
#	generated (domain generated domains) for use with botnets.  We do take
#	steps to sanitize this data to prevent inadvertant collisions with 
#	legitmate domains.  This is one of the largest rpz zones we produce.
#	If your server has limited ram it would probably not be a good idea
#	to implement this zone without testing beforehand.
#
#       - botnetcc.edit.host.dtq
#       - botnetcc.hacked.host.dtq (appears above in abused-legit)
#       - botnetcc.hacked.ip.dtq (appears above in abused-legit)
#       - botnetcc.host.dtq
#       - botnetcc.ip.dtq
#       - dga.host.dtq
#------------------------------------------------------------------------------

#rpz:
#	name: botnetcc.edit.host.dtq
#	zonefile: zonefiles/botnetcc.edit.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: botnetcc.edit.host.dtq

#rpz:
#	name: botnetcc.host.dtq
#	zonefile: zonefiles/botnetcc.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: botnetcc.host.dtq

#rpz:
#	name: botnetcc.ip.dtq
#	zonefile: zonefiles/botnetcc.ip.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: botnetcc.ip.dtq

#rpz:
#	name: dga.host.dtq
#	zonefile: zonefiles/dga.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: dga.host.dtq

#------------------------------------------------------------------------------
# Deteque Malware RPZ Zones
#       - malware.domains.dtq
#       - malware.edit.host.dtq
#       - malware.hacked.host.dtq (appears above in abused-legit)
#       - malware.host.dtq
#------------------------------------------------------------------------------

#rpz:
#	name: malware.domains.dtq
#	zonefile: zonefiles/malware.domains.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: malware.domains.dtq

#rpz:
#	name: malware.edit.host.dtq
#	zonefile: zonefiles/malware.edit.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: malware.edit.host.dtq

#rpz:
#	name: malware.host.dtq
#	zonefile: zonefiles/malware.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: malware.host.dtq

#------------------------------------------------------------------------------
# Deteque Bad Reputation RPZ Zones
#       - adware.edit.host.dtq
#       - adware.host.dtq
#       - bad-nameservers.host.dtq (not currently supported by Unbound)
#       - bad-nameservers.ip.dtq   (not currently supported by Unbound)
#       - badrep.edit.host.dtq
#       - badrep.hacked.host.dtq   (appears above in abused-legit)
#       - badrep.host.dtq
#       - bogons.ip.dtq
#------------------------------------------------------------------------------

#rpz:
#	name: adware.edit.host.dtq
#	zonefile: zonefiles/adware.edit.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: adware.edit.host.dtq

#rpz:
#	name: adware.host.dtq
#	zonefile: zonefiles/adware.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: adware.host.dtq

#rpz:
#	name: badrep.edit.host.dtq
#	zonefile: zonefiles/badrep.edit.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: badrep.edit.host.dtq

#rpz:
#	name: badrep.host.dtq
#	zonefile: zonefiles/badrep.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: badrep.host.dtq

#rpz:
#	name: bogons.ip.dtq
#	zonefile: zonefiles/bogons.ip.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: bogons.ip.dtq

#------------------------------------------------------------------------------
# Deteque Phishing RPZ Zones
#	These zones are designed to block access to phishing related sites.
#	The "edit" version of the zone is a subset of the phish.host.dtq 
#	domain whose reputation score is poorer.
#
#       - phish.edit.host.dtq
#       - phish.hacked.host.dtq (appears above in abused-legit)
#       - phish.host.dtq
#------------------------------------------------------------------------------

#rpz:
#	name: phish.edit.host.dtq
#	zonefile: zonefiles/phish.edit.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: phish.edit.host.dtq

#rpz:
#	name: phish.host.dtq
#	zonefile: zonefiles/phish.host.dtq
#	master: <distribution-masters>
#	rpz-log: yes
#	rpz-log-name: phish.host.dtq
